{"meta":{"title":"蜜罐技术研究小组","subtitle":"一个专注于蜜罐技术研究与交流的小站","description":"一个专注于蜜罐技术研究与交流的小站","author":"phantom0301","url":"http://ipot.sec-wiki.com"},"pages":[{"title":"","date":"2017-05-17T08:30:40.097Z","updated":"2017-01-12T10:24:34.000Z","comments":true,"path":"404.html","permalink":"http://ipot.sec-wiki.com/404.html","excerpt":"","text":"404 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#fff;margin-top:40px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=4; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num"},{"title":"","date":"2015-08-16T06:58:08.000Z","updated":"2017-05-19T09:57:55.487Z","comments":true,"path":"about/index.html","permalink":"http://ipot.sec-wiki.com/about/index.html","excerpt":"","text":"【理念】iPot提供一个蜜罐相关研究的交流与分享平台，定期收集互联网、学术圈、安全公司与蜜罐相关的研究成果，同时鼓励大家投稿，分享蜜罐研究方面的感悟心得。 iPot为对蜜罐研究感兴趣的初学者提供一个入门的平台，这里有开源的蜜罐项目、蜜罐论文的解读以及大家分享的蜜罐数据集。 【栏目介绍】 开源项目汇总： 收集蜜罐相关开源项目。根据该项目的最后更新时间进行排序 相关研究论文： 收集整理蜜罐领域发表的各种论文 蜜罐数据共享： 分享蜜罐相关数据集 小站三个栏目都接收大家的投稿，可以通过QQ群联系群主或邮箱进行投稿。 如果你有什么建议（包括栏目的删减、内容的增补），欢迎加入我们的交流群： 蜜罐研究交流群：137407808 联系邮箱： ipot@sec-wiki.com"},{"title":"Archives","date":"2016-08-16T07:00:24.000Z","updated":"2017-01-12T10:24:34.000Z","comments":true,"path":"archives/index.html","permalink":"http://ipot.sec-wiki.com/archives/index.html","excerpt":"","text":""},{"title":"datasets","date":"2016-08-16T07:00:44.000Z","updated":"2017-05-17T07:27:31.513Z","comments":false,"path":"datasets/index.html","permalink":"http://ipot.sec-wiki.com/datasets/index.html","excerpt":"","text":""},{"title":"papers","date":"2016-08-16T07:00:44.000Z","updated":"2017-05-17T07:27:41.475Z","comments":false,"path":"papers/index.html","permalink":"http://ipot.sec-wiki.com/papers/index.html","excerpt":"","text":""},{"title":"article","date":"2016-08-16T07:00:44.000Z","updated":"2017-05-18T02:34:43.431Z","comments":false,"path":"article/index.html","permalink":"http://ipot.sec-wiki.com/article/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2017-01-12T10:24:34.000Z","comments":true,"path":"tags/index.html","permalink":"http://ipot.sec-wiki.com/tags/index.html","excerpt":"","text":""},{"title":"projects","date":"2016-08-16T07:00:44.000Z","updated":"2017-05-17T05:45:41.669Z","comments":false,"path":"projects/index.html","permalink":"http://ipot.sec-wiki.com/projects/index.html","excerpt":"","text":""}],"posts":[{"title":"Mhn","slug":"honeypot-mhn","date":"2017-05-18T09:20:03.000Z","updated":"2017-05-18T09:30:00.356Z","comments":true,"path":"projects/2017-05-18-honeypot-mhn.html","link":"","permalink":"http://ipot.sec-wiki.com/projects/2017-05-18-honeypot-mhn.html","excerpt":"现代蜜网项目是Anomali公司的一款集管理界面、蜜罐部署于一体的蜜罐项目，支持多种检测规则，支持多种蜜罐节点，支持可视化界面管理，支持多用户 https://github.com/threatstream/mhn","text":"现代蜜网项目是Anomali公司的一款集管理界面、蜜罐部署于一体的蜜罐项目，支持多种检测规则，支持多种蜜罐节点，支持可视化界面管理，支持多用户 https://github.com/threatstream/mhn 介绍： MHN包含以下几部分： 蜜罐节点：支持包括Dionaea、Kippo、Snort、Conpot等多个开源蜜罐 管理服务器：使用Flask框架，通过API交互完成部署脚本下载，蜜罐信息接收、入侵规则更新、可视化展示等功能","categories":[{"name":"projects","slug":"projects","permalink":"http://ipot.sec-wiki.com/categories/projects/"}],"tags":[{"name":"蜜网","slug":"蜜网","permalink":"http://ipot.sec-wiki.com/tags/蜜网/"}]},{"title":"Dataset模板","slug":"Dataset20170518","date":"2017-05-18T07:55:53.000Z","updated":"2017-05-18T07:57:55.011Z","comments":true,"path":"datasets/2017-05-18-Dataset20170518.html","link":"","permalink":"http://ipot.sec-wiki.com/datasets/2017-05-18-Dataset20170518.html","excerpt":"xx年xx月xx日-xx日 xx蜜罐数据集 http://www.example.com/dataset.zip","text":"xx年xx月xx日-xx日 xx蜜罐数据集 http://www.example.com/dataset.zip 数据结构如下：","categories":[{"name":"datasets","slug":"datasets","permalink":"http://ipot.sec-wiki.com/categories/datasets/"}],"tags":[{"name":"数据集","slug":"数据集","permalink":"http://ipot.sec-wiki.com/tags/数据集/"},{"name":"dionaea","slug":"dionaea","permalink":"http://ipot.sec-wiki.com/tags/dionaea/"}]},{"title":"T-Pot多蜜罐平台：让蜜罐实现更简单","slug":"tpot","date":"2017-05-18T02:33:33.000Z","updated":"2017-05-18T03:47:38.710Z","comments":true,"path":"article/2017-05-18-tpot.html","link":"","permalink":"http://ipot.sec-wiki.com/article/2017-05-18-tpot.html","excerpt":"本文作者：失路之人，转载自FreeBuf.comhttp://www.freebuf.com/sectool/134504.html","text":"本文作者：失路之人，转载自FreeBuf.comhttp://www.freebuf.com/sectool/134504.html 这两年蜜罐技术被关注的越来越多，也渐形成低交互、中交互、高交互等交互程度的各类蜜罐，从web业务蜜罐、ssh应用蜜罐、网络协议栈蜜罐到系统主机型蜜罐的各功能型蜜罐。小到一个word文档的蜜标，到一个系统级的服务蜜罐，再到多功能蜜罐组成的蜜网，大到包含流控制重定向分布式蜜网组成的蜜场。 随着虚拟化技术的发展，各种虚拟蜜罐也得到发展，可以通过虚拟机来实现高交互蜜罐，以及通过docker实现的业务型蜜罐，不再像是以前需要昂贵硬件设备的部署支撑，这也大大减少了蜜罐的部署成本，一台主机就可以实现整个集数据控制，数据捕获和数据分析于一体多功能多蜜罐高交互蜜网的体系架构。也已经产生了一些不错的开源蜜罐产品或项目，比如MHN(现代蜜网)、HoneypotProject。 MHN现代蜜网简化了蜜罐的部署，集成了多种蜜罐的安装脚本，可以快速部署、使用，也能够快速的从节点收集数据。国外也有很多公司做基于蜜罐的欺骗技术产品创新。 蜜罐高保真高质量的数据集把安全人员从以前海量日志分析的繁琐过程中解脱出来，对于蜜罐的连接访问都是攻击信息，并且不再像以前的特征分析具有一定的滞后性，可以用于捕获新型的攻击和方法。前段时间作者就通过高交互蜜罐捕获了ssh自动化爆破工具，能够针对整个互联网进行爆破尝试，并能够自动识别某些低交互蜜罐。 现在各功能蜜罐这么多，虽然MHN简化了各蜜罐的部署过程，但还是需要手动安装多个系统sensor来实现多个不同蜜罐。在蜜罐的研究过程中，有没有一个提供能更简单方便的平台实现我们对蜜罐的研究与使用。 这里将介绍一个开源多蜜罐平台T-Pot16.10，安装一次系统，轻松使用里面多种蜜罐， 并且提供良好的可视化。官方英文介绍：https://dtag-[http://dev-sec.github.io/mediator/feature/2016/10/31/t-pot-16.10.html](http://dev-sec.github.io/mediator/feature/2016/10/31/t-pot-16.10.html “http://dev-sec.github.io/mediator/feature/2016/10/31/t-pot-16.10.html“) T-Pot16.10开源多蜜罐平台T-Pot16.10多蜜罐平台直接提供一个系统iso，里面使用docker技术实现多个蜜罐，更加方便的蜜罐研究与数据捕获。下面是刚把它部署到互联网6个小时的情况，先来看看它长什么，有没有使用的欲望。 是不是看到都想感受一下？别激动还是先介绍一下它。 T-Pot16.10 使用Ubuntuserver 16.04 LTS 系统，基于docker 技术提供了下面一些蜜罐容器： Conpot: 低交互工控蜜罐，提供一系列通用工业控制协议, 能够模拟复杂的工控基础设施。 Cowrie: 基于kippo更改的中交互ssh蜜罐, 可以对暴力攻击账号密码等记录，并提供伪造的文件系统环境记录黑客操作行为, 并保存通过wget/curl下载的文件以及通过SFTP、SCP上传的文件。 Dionaea: Dionaea是运行于Linux上的一个应用程序，将程序运行于网络环境下，它开放Internet常见服务的默认端口，当有外来连接时，模拟正常服务给予反馈，同时记录下出入网络数据流。网络数据流经由检测模块检测后按类别进行处理，如果有 shellcode 则进行仿真执行；程序会自动下载 shellcode 中指定或后续攻击命令指定下载的恶意文件。 Elasticpot: 模拟elastcisearch RCE漏洞的蜜罐，通过伪造函数在/,/_search, /_nodes的请求上回应脆弱ES实例的JSON格式消息。 Emobility: 在T-Pot中使用的高交互蜜罐容器， 旨在收集针对下一代交通基础设施的攻击动机和方法。Emobility蜜网包含一个中央收费系统，几个收费点，模拟用户的事务。一旦攻击者访问中控系统web界面，监控并处理运行收费交易，并与收费点交互。除此之外，在随机时间，黑客可能与正在收取车辆费用的用户进行交互。 Glastopf: 低交互型Web应用蜜罐, Glastopf蜜罐它能够模拟成千上万的web漏洞，针对攻击的不同攻击手段来回应攻击者，然后从对目标Web应用程序的攻击过程中收集数据。它的目标是针对自动化漏洞扫描/利用工具，通过对漏洞利用方式进行归类，针对某一类的利用方式返回对应的合理结果，以此实现低交互。 Honeytrap: 观察针对TCP或UDP服务的攻击，作为一个守护程序模拟一些知名的服务，并能够分析攻击字符串，执行相应的下载文件指令。 Conpot: 低交互工控蜜罐，提供一系列通用工业控制协议, 能够模拟复杂的工控基础设施。 Cowrie: 基于kippo更改的中交互ssh蜜罐, 可以对暴力攻击账号密码等记录，并提供伪造的文件系统环境记录黑客操作行为, 并保存通过wget/curl下载的文件以及通过SFTP、SCP上传的文件。 Dionaea: Dionaea是运行于Linux上的一个应用程序，将程序运行于网络环境下，它开放Internet常见服务的默认端口，当有外来连接时，模拟正常服务给予反馈，同时记录下出入网络数据流。网络数据流经由检测模块检测后按类别进行处理，如果有 shellcode 则进行仿真执行；程序会自动下载 shellcode 中指定或后续攻击命令指定下载的恶意文件。 Elasticpot: 模拟elastcisearch RCE漏洞的蜜罐，通过伪造函数在/,/_search, /_nodes的请求上回应脆弱ES实例的JSON格式消息。 Emobility: 在T-Pot中使用的高交互蜜罐容器， 旨在收集针对下一代交通基础设施的攻击动机和方法。Emobility蜜网包含一个中央收费系统，几个收费点，模拟用户的事务。一旦攻击者访问中控系统web界面，监控并处理运行收费交易，并与收费点交互。除此之外，在随机时间，黑客可能与正在收取车辆费用的用户进行交互。 Glastopf: 低交互型Web应用蜜罐, Glastopf蜜罐它能够模拟成千上万的web漏洞，针对攻击的不同攻击手段来回应攻击者，然后从对目标Web应用程序的攻击过程中收集数据。它的目标是针对自动化漏洞扫描/利用工具，通过对漏洞利用方式进行归类，针对某一类的利用方式返回对应的合理结果，以此实现低交互。 Honeytrap: 观察针对TCP或UDP服务的攻击，作为一个守护程序模拟一些知名的服务，并能够分析攻击字符串，执行相应的下载文件指令。 在这个平台上，使用了下面的这些工具： ELK: 优雅地可视化T-Pot捕获到的攻击事件 Elasticsearch-head: 一个web前端来浏览和操作ElasticSearch集群 Netdata: 实时性能监控 Portainer: docker的web操作界面 Suricate: 开源的网络安全威胁检测引擎。 Wetty: web界面的ssh客户端 T-Pot 是基于Ubuntu server 16.04TLS 的网络安装，因此安装过程中一定需要保证联网。这些蜜罐守护程序或者其他组件都通过docker虚拟化技术提供。这样可以使我们在一个网卡上运行多个蜜罐系统，并且整个系统更好维护。这些蜜罐程序封装在docker容器中提供了良好的隔离环境并且更容易更新。 这些事件可以通过数据分析工具ewsposter进行关联，也支持蜜网项目hpfeeds数据分享。 T-Pot蜜罐平台结构图： 在docker中的所有数据是隔离里，一旦docker容器崩溃，docker容器环境产生的所有数据都会消失并重启一个新的docker实例。因此，对于有些数据需要永久保存，例如配置文件，在主机上有个永久存储目录/data/， 在系统或者容器重启后都能持续有效。重要的日志数据也通过docker 指定vulume选项存储在容器外的主机文件系统/data/中， 容器里的应用程序能够将日志记录到该目录下。 该平台需要满足硬件要求： T-Pot 安装需要至少4G 内存， 64G 磁盘空间， 并且联网。 该系统安装步骤： 1.下载 top.iso 或者自己创建操作系统环境。 2.安装到联网的VM或者物理机上。安装过程跟普通安装Ubuntu 过程一样， 其中需要为tsec用户设置密码。 3.正常安装系统后，第一次启动系统时将选择安装类型，此时将根据选择下载安装相应容器服务。 有4种安装类型，不同安装类型需要的满足要求不一样， 我们这里选典型T-Pot安装。 1）T-Pot Installation (Cowrie, Dionaea, ElasticPot, Glastopf, Honeytrap, ELK, Suricata+P0f &amp; Tools) 2）Sensor Installation (Cowrie, Dionaea, ElasticPot, Glastopf, Honeytrap) 3）Industrial Installation (ConPot, eMobility, ELK, Suricata+P0f &amp; Tools) 4）Everything Installation (Everything, all of the above) 后面设置web 账号密码，再填写一些相关信息，自动完成docker镜像安装下载，安装成功后重新启动系统进入如下页面： 其中红色的为公网ip地址。 可能在安装过程中由于源的原因或者网络不稳定造成安装失败，这时后面可以登录到系统，用户名为tsec, 密码为安装系统时设置的密码， 进行sudo su 操作提升权限，手动执行/root/install.sh的安装脚本， 脚本检测出不是第一次安装将自动终止，这是需要清除一下文件/root/install.err, /root/install.log以及后面的错误提醒，也可以根据实际情况注释掉脚本已经完成的工作， 只继续进行中断未完成的命令。 4.正常安装系统后，第一次启动系统时将选择安装类型，此时将根据选择下载安装相应容器服务。 通过浏览器访问https://ip:64297访问T-Pot控制面板。通过安装时创建的web 账户密码验证登录。 前面我们已经将各攻击事件通过Kibana面板展示出来了， 我们也可以根据自己的需要设计这些面板可视化展示。 这里为了捕获到攻击，需要将T-Pot平台放置在互联网上，否则捕获不到任何攻击。我这里通过在路由器上设置DMZ将T-Pot放到互联网上。如果你是路由器做一个NAT转换来实现的话，这里需要把这些端口做NAT转换。 T-Pot平台不仅提供了蜜罐数据捕获，还有强大的ELK进行数据处理分析， 还能够处理Elk集群，把T-Pot中集成的多蜜罐可以分布式部署在多个系统上进行数据捕获并统一提供可视化分析展示。 还提供docker的web控制界面，直接可以通过web界面来管理控制我们的各个蜜罐容器。也能够根据需要设计自己的容器蜜罐或容器服务。 还提供了Web ssh 客户端，通过web控制台直接就登录了系统进行操作了，系统实际的22端口 ssh服务其实是一个cowrie蜜罐。 这样我们通过控制台就能方便的登录到实际系统， 设计方便。 还有强大的系统性能监控平台，实时监控主机系统和各容器资源使用情况。 你也可以使用ISO Creator 来创建你自己的ISO安装镜像。 创建镜像要求： Ubuntu 16.04 LTS 或者更新的系统作为主机系统，其他系统没有测试，至少4G内存，32G磁盘空间。 创建ISO镜像： 克隆仓库并进入目录 git clone https://github.com/dtag-dev-sec/tpotce.git cd tpotce 调用脚本来建立ISO镜像， 这个脚本将下载安装一些必须的依赖包。它将下载T-Pot基于的ubuntu网络安装镜像（大约50M）. sudo./makeiso.sh 成功后你将在目录下发现tpot.iso和tpot.sha256两个文件。 现在可以方便的玩蜜罐了。前段时间自己也封装了一些docker高交互蜜罐容器，现在可以方便地集成到T-Pot平台上了， 让蜜罐部署更简单， 功能更丰富。","categories":[{"name":"article","slug":"article","permalink":"http://ipot.sec-wiki.com/categories/article/"}],"tags":[{"name":"蜜罐","slug":"蜜罐","permalink":"http://ipot.sec-wiki.com/tags/蜜罐/"},{"name":"T-Pot","slug":"T-Pot","permalink":"http://ipot.sec-wiki.com/tags/T-Pot/"},{"name":"Docker","slug":"Docker","permalink":"http://ipot.sec-wiki.com/tags/Docker/"}]},{"title":"MongoDB-HoneyProxy","slug":"honeypot-mongodb","date":"2017-02-25T03:53:08.000Z","updated":"2017-05-18T05:52:35.412Z","comments":true,"path":"projects/2017-02-25-honeypot-mongodb.html","link":"","permalink":"http://ipot.sec-wiki.com/projects/2017-02-25-honeypot-mongodb.html","excerpt":"一款基于MongoDB数据库代理实现的蜜罐 https://github.com/Plazmaz/MongoDB-HoneyProxy","text":"一款基于MongoDB数据库代理实现的蜜罐 https://github.com/Plazmaz/MongoDB-HoneyProxy 介绍： 这个蜜罐是由MongoDB Apocalypse项目衍生出来的。纯JS语言编写。 注意：你不应该在真实使用的数据库上加入该蜜罐。","categories":[{"name":"projects","slug":"projects","permalink":"http://ipot.sec-wiki.com/categories/projects/"}],"tags":[{"name":"蜜罐","slug":"蜜罐","permalink":"http://ipot.sec-wiki.com/tags/蜜罐/"},{"name":"数据库","slug":"数据库","permalink":"http://ipot.sec-wiki.com/tags/数据库/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://ipot.sec-wiki.com/tags/MongoDB/"}]},{"title":"Nosqlpot","slug":"honeypot-nosqlpot","date":"2017-01-19T05:38:24.000Z","updated":"2017-05-18T05:57:16.933Z","comments":true,"path":"projects/2017-01-19-honeypot-nosqlpot.html","link":"","permalink":"http://ipot.sec-wiki.com/projects/2017-01-19-honeypot-nosqlpot.html","excerpt":"一个组件式的Nosql蜜罐框架，现在支持CouchDB和Redis两种数据库 https://github.com/torque59/nosqlpot","text":"一个组件式的Nosql蜜罐框架，现在支持CouchDB和Redis两种数据库 https://github.com/torque59/nosqlpot 介绍： NoSQL-Honeypot-Framework(Nopo)是一个开源的nosql数据库蜜罐框架，可以自动化检测攻击者，记录攻击事件。整个框架使用python语言twisted实现，仍在开发中。","categories":[{"name":"projects","slug":"projects","permalink":"http://ipot.sec-wiki.com/categories/projects/"}],"tags":[{"name":"蜜罐","slug":"蜜罐","permalink":"http://ipot.sec-wiki.com/tags/蜜罐/"},{"name":"数据库","slug":"数据库","permalink":"http://ipot.sec-wiki.com/tags/数据库/"},{"name":"nosql","slug":"nosql","permalink":"http://ipot.sec-wiki.com/tags/nosql/"}]},{"title":"用树莓派搭建小型honeynet","slug":"rasb-honeynet","date":"2016-12-20T07:48:05.000Z","updated":"2017-05-22T08:44:07.903Z","comments":true,"path":"article/2016-12-20-rasb-honeynet.html","link":"","permalink":"http://ipot.sec-wiki.com/article/2016-12-20-rasb-honeynet.html","excerpt":"本文作者：，转载自MottoINhttp://www.mottoin.com/94306.html","text":"本文作者：，转载自MottoINhttp://www.mottoin.com/94306.html 前言树莓派小巧且耗费的电量非常少，如果你有一两个备用的，你可以使用他们来搭建蜜罐。 温馨提示：尽管蜜罐软件通常与底层操作系统隔离，但是也有存在错误以及发生事故的可能，所以不应该在托管蜜罐软件的系统上运行任何服务。 不建议在共享网络环境中运行无人值守的蜜罐。即使是低端的路由器现在也有某种DMZ选项可用于此活动，但更好的选择是使用具有严格和带宽限制的专用IP网络。 蜜罐及其环境应始终被视为已经沦陷的，下载到蜜罐的文件和脚本可能有危险，不应在其他地方运行。如果你已经厌倦了对入侵蜜罐的人的观察分析，可以彻底擦除它，完全重新安装。 安装我的一个蜜罐实验室包括两个树莓派。一个处理SSH和Telnet连接，而另一个处理HTTP、SMTP、POP3和IRC。如下所述，在必要的时候，他们之间还可以进行通信。 在本实验中，两个树莓派节点都运行自己的缓存DNS服务器和NTP服务器。 两者都由IDS监控，并且监控非常频繁，如果需要进一步分析，则保存所有入站和出站网络流量（完全数据包捕获）。 CowireSSH/telnet蜜罐运行Cowrie，一个非常好的基于Kippo的蜜罐软件。Cowrie模仿SSH和telnet服务，并将接受基于可配置用户/密码列表的登录尝试。成功登录后，入侵者将发现自己在完全虚拟化的文件系统中，很多可用的命令和二进制文件。执行的每个操作都将被记录，如果入侵者下载工具包或其他工具以进一步利用，则每个下载的文件的副本将被存储在虚拟化环境外部以供分析。 Cowrie可以配置为直接记录到确定的数据库、Splunk、Elasticsearch以及普通文本和JSON等常规日志文件中。还有一个选项用于将下载的文件提交到VirusTotal进行分析。 InetSim另一个蜜罐节点运行InetSim，一个模拟多个服务的蜜罐软件，纯文本和加密（SSL/TLS）。 几乎每个服务参数都可以被入侵者或其他访问者配置。不是所有的入侵者都会对运行在AIX/370主机上的IIS服务器产生反应。 当查询HTTP请求时，InetSim将很乐意为基于MIME类型预配置的任何内容提供服务，如果没有，则为默认值。 使用POST的HTTP提交将存储在单个文件中。例如，最近的Mirai僵尸网络，分析postdata文件已经有助于识别不断变化的服务器漏洞下载第2阶段恶意软件。 InetSim的SMTP进程可以配置为已认证的邮件中继。它将接受和记录提交的电子邮件，但显然永远不会发送它。除了收集入侵者将用于获取访问权限的凭据之外，InetSim还将存储提交到此伪造邮件服务器的每个邮件的内容以进行传送。 由于通过此蜜罐提交的邮件接近100％垃圾邮件，除了零星的邮件报告发现一个可利用的继电器，单独的计划任务将自动将此邮件提供给Pyzor以改进其垃圾邮件数据库。目前，该蜜罐每天提交5000至2万封邮件。 协同工作因为很多获得Cowrie蜜罐SSH访问的人尝试使用它作为发送垃圾邮件或提交链接垃圾邮件或论坛垃圾邮件的bouncer，Cowrie非常方便地提供重定向出站请求。 默认情况下不允许出站连接，让攻击者看起来象连接超时，但重定向将允许指定的端口到达配置的目标。 对于在InetSim蜜罐上运行的每个假服务，来自Cowrie的出站连接将终止在那里。 直接使用SMTP和通过SSH隧道使用SMTP这两个垃圾邮件发送者将到达InetSim蜜罐。 在Cowrie中，重定向配置如下（在本例中为25端口）： forward_redirect_25 = inetsim-honeypot:25 有趣的部分运行提供有关当前攻击、僵尸网络、rootkit、木马和其他工具信息的蜜罐。通过正确配置的日志记录，它们提供了连续有用的信息流，例如频繁地尝试用户名/密码组合，下载rootkit的URL或IP地址，并且通过使用GeoIP信息，将很容易暴露入侵者来自哪里 。 Cowrie还提供了一个用于重播已登录会话的工具，显示入侵期间发生的具体情况。 僵尸网络和脚本通常是可预测的，但现在又是一个尝试… 大多数入侵都是自动机器人，但上图这一个看起来象是人为的（充满疑问）。","categories":[{"name":"article","slug":"article","permalink":"http://ipot.sec-wiki.com/categories/article/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://ipot.sec-wiki.com/tags/树莓派/"},{"name":"honeynet","slug":"honeynet","permalink":"http://ipot.sec-wiki.com/tags/honeynet/"}]},{"title":"Glastopf","slug":"honeypot-glastopf","date":"2016-10-10T06:30:51.000Z","updated":"2017-05-18T06:36:58.610Z","comments":true,"path":"projects/2016-10-10-honeypot-glastopf.html","link":"","permalink":"http://ipot.sec-wiki.com/projects/2016-10-10-honeypot-glastopf.html","excerpt":"一个通用的web应用蜜罐 https://github.com/mushorg/glastopf","text":"一个通用的web应用蜜罐 https://github.com/mushorg/glastopf 介绍： Glastopf是一个用Python语言写成的web应用框架，它主要用来对抗Google-dork攻击，通过返回含有多个关键字的页面，Glastopf还能够有效的欺骗扫描器。","categories":[{"name":"projects","slug":"projects","permalink":"http://ipot.sec-wiki.com/categories/projects/"}],"tags":[{"name":"蜜罐","slug":"蜜罐","permalink":"http://ipot.sec-wiki.com/tags/蜜罐/"},{"name":"web","slug":"web","permalink":"http://ipot.sec-wiki.com/tags/web/"}]},{"title":"自制蜜罐之前端部分","slug":"fronted","date":"2016-07-08T08:02:00.000Z","updated":"2017-05-22T08:46:38.841Z","comments":true,"path":"article/2016-07-08-fronted.html","link":"","permalink":"http://ipot.sec-wiki.com/article/2016-07-08-fronted.html","excerpt":"本文作者：netxfly，转载自www.xsec.iohttps://www.xsec.io/2016/7/8/how-to-develop-a-honeypot.html","text":"本文作者：netxfly，转载自www.xsec.iohttps://www.xsec.io/2016/7/8/how-to-develop-a-honeypot.html 自制蜜罐背景生产系统的内网部署蜜罐后可以监控到黑客对内网的探测及攻击行为，方便安全工程师第一时间发现被入侵并及时止损，防止出现公司重要数据被窃取却浑然不然的情况。 所以我们有必要在重要业务的内网机房部署蜜罐。 需求 第一时间发现攻击者 攻击行为及指纹记录、识别 覆盖到全部的协议及端口 目前市面上已经有许多商业或开源的蜜罐系统，如awesome-honeypots中收集了大量的开源的蜜罐系统， 但是这些开源的蜜罐系统存在以下问题： 安装、部署比较复杂、繁琐，学习成本高 自定义或扩展功能的成本高 覆盖不到全部的协议及端口 开发进度滞后，没有覆盖到最新的redis、elastic、stuct2等漏洞的利用的监控 所以我们有必要自己开发一套易于部署、覆盖全端口全协议及最新漏洞的蜜罐系统。 蜜罐架构图 Agent 记录攻击log并发送到server中 按照策略将攻击流量转到后端server 定期更新policy Server: 接收来自各agent的攻击log 通过策略判断是否需要报警 攻击log及报警log保存、备份 Backend 利用docker构建常见的各服务 攻击行为记录、指纹识别 Policy server Agent和server的策略管理 Agent的实现Agent利用iptables记录了对Agent所有端口的tcp及udp协议的访问log，并用iptables将请求按policy指定的规则转到了后端的攻击行为识别服务器中。 iptables基础netfilter/iptables（简称为iptables）组成Linux平台下的包过滤防火墙，与大多数的Linux软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换（NAT）等功能。 Netfilter是Linux操作系统核心层内部的一个数据包处理模块，它具有如下功能： 网络地址转换(Network Address Translate) 数据包内容修改 包过滤的防火墙功能 真正实现防火墙功能的是处于内核级的netfilter，iptables是应用层的netfilter的管理工具，netfilter与iptables在linux操作系统中的位置及角色如下图所示： Netfilter提供了数据包的5个Hook Point，当有数据通过这些位置时，钩子就会触发，从而可以调用我们自定义的函数，这5个挂载点分别为： NF_IP_PRE_ROUTING NF_IP_LOCAL_IN NF_IP_FORWARD NF_IP_LOCAL_OUT NF_IP_POST_ROUTING Netfilter所设置的规则是存放在内核内存中的，而 iptables 是一个应用层的应用程序，它通过 Netfilter 放出的接口来对存放在内核内存中的 XXtables（Netfilter的配置表）进行修改。 这个XXtables由表tables、链chains、规则rules组成，iptables在应用层负责修改这个规则文件。 iptables内置了4个表，即Filter表、Nat表、Mangle表和Raw表，分别用于实现包过滤、网络地址转换、包重构(修改)和数据跟踪处理。 这几个表的优先顺序为Raw -&gt; Mangle -&gt; Nat -&gt; Filter。 iptables表和链的结构如下图所示： iptables中的规则表（table） Raw表有两个链：OUTPUT、PREROUTING，作用为决定数据包是否被状态跟踪机制处理 Mangle表有五个链：PREROUTING、POSTROUTING、INPUT、OUTPUT、FORWARD，作用为修改数据包的服务类型、TTL、并且可以配置路由实现QOS Nat表有三个链：PREROUTING、POSTROUTING、OUTPUT，作用为用于网络地址转换 Filter表有三个链：INPUT、FORWARD、OUTPUT，作用为数据包过滤 iptables中的规则链接（chain） INPUT——进来的数据包应用此规则链中的策略。 OUTPUT——外出的数据包应用此规则链中的策略。 FORWARD——转发数据包时应用此规则链中的策略。 PREROUTING——对数据包作路由选择前应用此链中的规则，所有的数据包进来的时侯都先由这个链处理。 POSTROUTING——对数据包作路由选择后应用此链中的规则，所有的数据包出来的时侯都先由这个链处理。 iptales中的数据流 iptables中的数据流可以总结为以下3句话： 发往本地的包，数据流向为：PREROUTING -&gt; INPUT 发往其他地址的包，数据流向为：PREROUTING -&gt; FORWARD -&gt; POSTROUTING 从本地发出的包的数据流向为： OUTPUT -&gt; POSTROUTING iptables规则管理 iptables命令参数[-t 表名]：该规则所操作的哪个表，可以使用filter、nat等，如果没有指定则默认为filter -A：新增一条规则，到该规则链列表的最后一行 -I：插入一条规则，原本该位置上的规则会往后顺序移动，没有指定编号则为1 -D：从规则链中删除一条规则，要么输入完整的规则，或者指定规则编号加以删除 -R：替换某条规则，规则替换不会改变顺序，而且必须指定编号。 -P：设置某条规则链的默认动作 -nL：-L、-n，查看当前运行的防火墙规则列表 chain名：指定规则表的哪个链，如INPUT、OUPUT、FORWARD、PREROUTING等 [规则编号]：插入、删除、替换规则时用，--line-numbers显示号码 [-i|o 网卡名称]：i是指定数据包从哪块网卡进入，o是指定数据包从哪块网卡输出 [-p 协议类型]：可以指定规则应用的协议，包含tcp、udp和icmp等 [-s 源IP地址]：源主机的IP地址或子网地址 [--sport 源端口号]：数据包的IP的源端口号 [-d目标IP地址]：目标主机的IP地址或子网地址 [--dport目标端口号]：数据包的IP的目标端口号 -m：extend matches，这个选项用于提供更多的匹配参数，如： -m state --state ESTABLISHED,RELATED -m tcp --dport 22 -m multiport --dports 80,8080 -m icmp --icmp-type 8 &lt;-j 动作&gt;：处理数据包的动作，包括ACCEPT、DROP、REJECT等 利用shell实现一个demo#!/bin/bash :&lt;&lt;BLOCK Copyright (c) 2016 www.xsec.io - User: netxfly&lt;x@xsec.io&gt; - Date: 2016/6/20 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. BLOCK WHITELIST_IPs=(1.1.1.1.1 111.111.111.111 222.222.222.222) WHITELIST_PORTS=&quot;88,96,99,55522&quot; BACKEND=&quot;10.10.10.10&quot; ATTACK_IP=&quot;9.9.9.9.9&quot; ATTACK_IP1=&quot;9.9.9.9.0/24&quot; UNREAL_TARGET=&quot;220.181.112.244:80&quot; # set ip_forward function set_ip_forward() { /sbin/sysctl -w net.ipv4.ip_forward=1 sysctl -p } # delete custom iptables chain function delete_policy() { /sbin/iptables -t nat -F /sbin/iptables -t nat -X HONEYPOT /sbin/iptables -t nat -X FIREWALL_IN /sbin/iptables -t nat -X FIREWALL_OUT /sbin/iptables -t filter -F /sbin/iptables -t filter -X WHITELIST } # init iptables chain function init_policy() { /sbin/iptables -t nat -N HONEYPOT /sbin/iptables -t nat -A PREROUTING -j HONEYPOT /sbin/iptables -t filter -N WHITELIST /sbin/iptables -t filter -A INPUT -j WHITELIST /sbin/iptables -t nat -N FIREWALL_IN /sbin/iptables -t nat -A PREROUTING -j FIREWALL_IN /sbin/iptables -t nat -N FIREWALL_OUT /sbin/iptables -t nat -A POSTROUTING -j FIREWALL_OUT /sbin/iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE /sbin/iptables -t nat -A HONEYPOT -i eth0 -p tcp -m state --state NEW,ESTABLISHED,RELATED -j LOG --log-prefix &quot;iptables:&quot; } # set white policy(ip white) function set_white_policy() { for ip in $WHITELIST_IPs do /sbin/iptables -t filter -A WHITELIST -s $ip -j DROP done } # set honeypot policy(ports white) function set_honeypot_policy() { /sbin/iptables -A HONEYPOT -t nat -i eth0 -p tcp -m multiport ! --dport $WHITELIST_PORTS -j DNAT --to-destination $BACKEND /sbin/iptables -A HONEYPOT -t nat -i eth0 -p udp -m multiport ! --dport $WHITELIST_PORTS -j DNAT --to-destination $BACKEND # /sbin/iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE } # start honeypot function StartHoneypot() { set_ip_forward init_policy set_white_policy set_honeypot_policy } # stop honeypot function StopHoneypot() { delete_policy } function showHelp() { echo &quot;Usage: [sudo] ./honeypot.sh [OPTIONS]&quot; echo &quot;Options:&quot; echo -e &quot;\\t-h | --help\\t\\t show this help&quot; echo -e &quot;\\t-start \\t\\t start honeypot&quot; echo -e &quot;\\t-stop \\t\\t stop honeypot&quot; } # Check if user is root [ $(id -u) != &quot;0&quot; ] &amp;&amp; { echo &quot;Must run as root, exit1111...&quot; &gt;&amp;2; exit 1; } while true ; do case &quot;$1&quot; in -h|--help) showHelp; echo &quot;&quot; exit 0 ;; -start|--start) echo &quot;start honeypot&quot;; StartHoneypot; exit 0 ;; -stop|--stop) echo &quot;stop honeypot&quot;; StopHoneypot; exit 0 ;; *) # echo &quot;invalid option. $1&quot; showHelp; exit 1 ;; esac done function policy_reset() { /sbin/iptables -t nat -F FIREWALL_IN /sbin/iptables -t nat -F FIREWALL_OUT iptables -t nat -A FIREWALL_OUT -o eth0 -j MASQUERADE } # # douzhuanxingyi function douzhuanxingyi() { iptables -t nat -A FIREWALL_IN -s $ATTACK_IP -j DNAT --to-destination $ATTACK_IP } function jinghuashuiyue() { /sbin/iptables -t nat -A FIREWALL_IN -i eth0 -p tcp -m tcp --dport 1:65535 -s $ATTACK_IP1 -j DNAT --to-destination $UNREAL_TARGET demo代码解读 set_ip_forward函数将net.ipv4.ip_forward设为了1，这样才能开启linux的数据转发功能。 init_policy中利用-N指令新建了不同的chain，目的是为了在将同类的操作放到同一个链中，防止在操作规则的过程中影响到其他的iptables规则。 set_white_policy为设置白名单，来自白名单的请求直接drop掉，不会转到后端服务器； set_honeypot_policy为设置蜜罐的转发规则，除了服务器管理、监控外的其他端口外的其他请求全部转到后端 douzhuanxingyi使用了金庸武侠小说《天龙八部》中武功名，指将攻击者的攻击全部反弹回去 jinghuashuiyue是使用了动画片《死神》中蓝染的斩魄刀的名字：(幻觉系最强斩魄刀），指将攻击者的所有请求转到一个伪造的地址中，误导攻击者。 在使用了DNAT后，需要在POSTROUTING链中设置SNAT，每条规则都需要设置，操作麻烦且容易出错，用-j MASQUERADE可以自动完成这些操作 golang实现最终的agent相比python来说，golang写的程序无任何依赖，直接编译为一个二进制文件就能执行，所以我们选择了golang。 agent的功能为： 支持配置，配置文件中为策略的URL，转发数据的网卡名 定期从策略服务器中拉取最新的策略并应用 将syslog发送到后端的server中 发送syslog到后端服务器的功能无需开发，centos 6默认全部为rsyslog，只需配置下rsyslog便可将日志发送到后端server， 配置完需重启rsyslog服务/etc/init.d/rsyslog restart，配置参数如下： [root@honeypot_agent01 agent]# cat /etc/rsyslog.d/iptables.conf :msg,contains,&quot;iptables&quot; @@111.111.111.111:514 111.111.111.111 为蜜罐的server，514为端口，@@表示以TCP发送log，@表示以UDP发送数据 建议全部使用TCP，个别网络的ACL导致tcp不通时可以使用udp。 agent的定期运行配置在cronta中，每1分钟更新一次策略 [root@honeypot_agent01 agent]# crontab -e */1 * * * * /data/honeypot/agent/honeypot_agent Agent的部分代码如下： // Get forward policy &amp;&amp; white list func GetPolicy() (p Policys, err error) { resp, err := http.Get(Url) if err != nil { log.Fatal(err) } body, err := ioutil.ReadAll(resp.Body) if err != nil { log.Fatal(err) } json.Unmarshal(body, &amp;p) resp.Body.Close() return p, err } // set iptables func SetIptables(policy Policys) { // InitPolicy() white_ip_policy := policy.Whiteip // set white policy for _, white_ip := range white_ip_policy { fmt.Println(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;filter&quot;, &quot;-A&quot;, &quot;WHITELIST&quot;, &quot;-i&quot;, interfaceName, &quot;-s&quot;, white_ip, &quot;-j&quot;, &quot;DROP&quot;) exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;filter&quot;, &quot;-A&quot;, &quot;WHITELIST&quot;, &quot;-i&quot;, interfaceName, &quot;-s&quot;, white_ip, &quot;-j&quot;, &quot;DROP&quot;).Output() } fmt.Println(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;nat&quot;, &quot;-A&quot;, &quot;HONEYPOT&quot;, &quot;-i&quot;, interfaceName, &quot;-p&quot;, &quot;tcp&quot;, &quot;-m&quot;, &quot;multiport&quot;, &quot;!&quot;, &quot;--dports&quot;, strings.Join(policy.Whiteport, &quot;,&quot;), &quot;-j&quot;, &quot;DNAT&quot;, &quot;--to-destination&quot;, policy.Backend) ret, err := exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;nat&quot;, &quot;-A&quot;, &quot;HONEYPOT&quot;, &quot;-i&quot;, interfaceName, &quot;-p&quot;, &quot;tcp&quot;, &quot;-m&quot;, &quot;multiport&quot;, &quot;!&quot;, &quot;--dports&quot;, strings.Join(policy.Whiteport, &quot;,&quot;), &quot;-j&quot;, &quot;DNAT&quot;, &quot;--to-destination&quot;, policy.Backend).Output() fmt.Println(ret, err) exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;nat&quot;, &quot;-A&quot;, &quot;POSTROUTING&quot;, &quot;-o&quot;, interfaceName, &quot;-j&quot;, &quot;MASQUERADE&quot;).Output() } // set ipv4.ip_forward func SetIp_forward() { cmd := exec.Command(&quot;/sbin/sysctl&quot;, &quot;-w&quot;, &quot;net.ipv4.ip_forward=1&quot;) cmd.Run() cmd = exec.Command(&quot;/sbin/sysctl&quot;, &quot;-p&quot;) cmd.Run() } // Init iptables policy func InitPolicy() { // set honeypot chain in nat table exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;nat&quot;, &quot;-N&quot;, &quot;HONEYPOT&quot;).Run() exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;nat&quot;, &quot;-F&quot;, &quot;HONEYPOT&quot;).Run() exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;nat&quot;, &quot;-A&quot;, &quot;PREROUTING&quot;, &quot;-j&quot;, &quot;HONEYPOT&quot;).Run() exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;nat&quot;, &quot;-A&quot;, &quot;HONEYPOT&quot;, &quot;-i&quot;, interfaceName, &quot;-p&quot;, &quot;tcp&quot;, &quot;-m&quot;, &quot;state&quot;, &quot;--state&quot;, &quot;NEW,ESTABLISHED,RELATED&quot;, &quot;-j&quot;, &quot;LOG&quot;, &quot;--log-prefix&quot;, &quot;iptables &quot;).Run() // set white list chain in filter table exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;filter&quot;, &quot;-N&quot;, &quot;WHITELIST&quot;).Run() exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;filter&quot;, &quot;-F&quot;, &quot;WHITELIST&quot;).Run() exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;filter&quot;, &quot;-A&quot;, &quot;INPUT&quot;, &quot;-j&quot;, &quot;WHITELIST&quot;).Run() } // Delete Policy func DeletePolicy() { // Flush rule exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;nat&quot;, &quot;-F&quot;).Run() exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;filter&quot;, &quot;-F&quot;).Run() // delete chain exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;nat&quot;, &quot;-X&quot;, &quot;HONEYPOT&quot;).Run() exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;filter&quot;, &quot;-X&quot;, &quot;WHITELIST&quot;).Run() } // Start Agent func Start(p Policys) { Stop() // set ip forward SetIp_forward() // create iptables chain InitPolicy() // set iptables rule SetIptables(p) } // Stop Agent func Stop() { // clean iptables rule and chain DeletePolicy() } Server的实现蜜罐server使用gopkg.in/mcuadros/go-syslog.v2包实现了一个rsyslog server，将每条收到的rsyslog进行格式化，然后判断是否在白名单中，如果不在白名单中，然后对攻击数据进行计数（超过一定的时间后再开始从0开始计数）， 如果在规定的时间内超过配置的报警的次数后就不会再报了，防止短时间内产生大量的垃圾邮件。 比如可以把策略设为：同一个来源的攻击者，3分钟内只发1封报警邮件，报警策略的代码如下： // check if send alarm mail func AlarmPolicy(redisConfig RedisConfig, sysLog map[string]interface{}) (isAlarm bool) { client := redis.NewClient(&amp;redis.Options{ Addr: fmt.Sprintf(&quot;%s:%d&quot;, redisConfig.Host, redisConfig.Port), Password: redisConfig.Password, // password set DB: redisConfig.Db, // use default DB }) src, ok := sysLog[&quot;src&quot;].(string) if ok { bRet, _ := client.Exists(src).Result() if bRet { client.HIncrBy(src, &quot;times&quot;, 1) // client.Expire(src, time.Duration(redisConfig.Duration)*time.Minute) } else { client.HSet(src, &quot;times&quot;, &quot;1&quot;) client.Expire(src, time.Duration(redisConfig.Duration)*time.Minute) } strRet, _ := client.HGet(src, &quot;times&quot;).Result() ret, _ := strconv.Atoi(strRet) fmt.Printf(&quot;strRet:%v, ret:%v, AlarmOffTime:%v\\n&quot;, strRet, ret, redisConfig.AlarmOffTime) if ret &lt;= redisConfig.AlarmOffTime { isAlarm = true } } return isAlarm } // send alarm mail func Alarm(redisConfig RedisConfig, sysLog map[string]interface{}, subject string, body string, mail_config MailConfig, alarmInfo AlarmInfo) { if AlarmPolicy(redisConfig, sysLog) { go SendMail(subject, body, mail_config) go InsertElastic(*alarmInfo.Client, alarmInfo.EsIndex, alarmInfo.EsDocument, alarmInfo.Id, alarmInfo.LogParts) } } 以下为server处理rsyslog的核心代码： func main() { Loadconfig() channel := make(syslog.LogPartsChannel) handler := syslog.NewChannelHandler(channel) server := syslog.NewServer() server.SetFormat(syslog.Automatic) server.SetHandler(handler) server.ListenUDP(&quot;0.0.0.0:514&quot;) server.ListenTCP(&quot;0.0.0.0:514&quot;) server.Boot() go func(channel syslog.LogPartsChannel) { client, err := helper.ConnectElastic(es_info) log.Println(client, err, syslogConfig.Backup) for logParts := range channel { // fmt.Printf(&quot;%V,%v\\n&quot;, logParts, logParts) value, ok := logParts[&quot;content&quot;].(string) if ok { // backup syslog to localhost if syslogConfig.Backup == 1 { go helper.BackupSyslog(syslogConfig.Tag, value) } ret := helper.ParseLogContent(value) // logParts[&quot;content&quot;] = ret // fmt.Println(ret) delete(logParts, &quot;content&quot;) for k, v := range ret { logParts[k] = v } // fmt.Println(&quot;logParts: &quot;, logParts) p, _ := helper.GetPolicy(Url) white_list := helper.GetWhiteList(p) white_ports := helper.GetWhitePort(p) src := ret[&quot;src&quot;] id := ret[&quot;id&quot;] dpt := ret[&quot;dpt&quot;] // for mail content template var mailContent helper.MailContent Timestamp, _ := logParts[&quot;timestamp&quot;].(time.Time) mailContent.Timestamp = Timestamp.Format(&quot;2006-01-02 15:04:05&quot;) mailContent.SrcIp, _ = logParts[&quot;src&quot;].(string) mailContent.SrcHostname, _ = helper.GetHostNameByIp(mailContent.SrcIp) mailContent.SrcPort, _ = logParts[&quot;spt&quot;].(string) mailContent.Proto, _ = logParts[&quot;proto&quot;].(string) mailContent.DestIp, _ = logParts[&quot;dst&quot;].(string) mailContent.DestPort, _ = logParts[&quot;dpt&quot;].(string) mailContent.Hostname, _ = logParts[&quot;hostname&quot;].(string) mailContent.Color = helper.GetColor() log.Println(white_list, src, white_ports, dpt, mailContent) if !white_list[src] &amp;&amp; !white_ports[dpt] { subject := fmt.Sprintf(&quot;[蜜罐报警]%v, 截获来自%v:%v对%v:%v的攻击(%v)&quot;, mailContent.Timestamp, src, ret[&quot;spt&quot;], ret[&quot;dst&quot;], ret[&quot;dpt&quot;], ret[&quot;proto&quot;]) // body, _ := json.MarshalIndent(logParts, &quot;&quot;, &quot;\\t&quot;) t, _ := template.New(&quot;mail&quot;).Parse(helper.HtmlMail) var body bytes.Buffer t.Execute(&amp;body, mailContent) // Alarm info, save to es too var alarmInfo helper.AlarmInfo alarmInfo.Client = client alarmInfo.EsIndex = es_info.Index alarmInfo.EsDocument = es_info.DocumentAlarm alarmInfo.Id = id alarmInfo.LogParts = logParts go helper.Alarm(redisConfig, logParts, subject, fmt.Sprintf(&quot;%s&quot;, body.String()), mail_config, alarmInfo) go helper.InsertElastic(*client, es_info.Index, es_info.Document, id, logParts) } } // log.Println(strings.Repeat(&quot;-&quot;, 70)) } }(channel) server.Wait() } 蜜罐的测试效果： 扩展功能以上的Agent放在重要系统的内网网段为一个支持所有协议和端口的蜜罐，其实也可以改为一个适用于小网站的防火墙放在外网。 做成防火墙需要做的改动如下： 去掉数据转发到后端的功能 设计防火墙策略（以下仅为举例，正式使用的话，需要根据对不同的端口的攻击设置不同的频率）例如： - 如果1分钟内同一个IP的请求超过100，可以将攻击者的所有请求转到一个欺骗的地址（镜花水月） - 如果1分钟内同一个IP的请求超过300，可以将攻击者的所有请求原封不动的反弹回去（斗转星移） - 如果1分钟内同一个IP的请求超过600，直接将攻击者的IP Block掉，禁止访问。 参考资料https://n0where.net/how-does-it-work-iptables/ http://txgcwm.github.io/blog/2013/07/25/linuxxia-iptablesfang-huo-qiang-yuan-li-ji-shi-yong/ https://segmentfault.com/a/1190000002540601","categories":[{"name":"article","slug":"article","permalink":"http://ipot.sec-wiki.com/categories/article/"}],"tags":[{"name":"蜜罐","slug":"蜜罐","permalink":"http://ipot.sec-wiki.com/tags/蜜罐/"},{"name":"前端","slug":"前端","permalink":"http://ipot.sec-wiki.com/tags/前端/"}]},{"title":"MHN开源蜜罐项目学习笔记（一）HPFEEDS协议","slug":"hpfeeds","date":"2016-02-19T09:13:55.000Z","updated":"2017-05-22T08:45:35.178Z","comments":true,"path":"article/2016-02-19-hpfeeds.html","link":"","permalink":"http://ipot.sec-wiki.com/article/2016-02-19-hpfeeds.html","excerpt":"Hpfeeds和蜜罐是一对好搭档，想要完全掌握一个分布式蜜罐的信息传递，就来了解Hpfeeds协议吧！","text":"Hpfeeds和蜜罐是一对好搭档，想要完全掌握一个分布式蜜罐的信息传递，就来了解Hpfeeds协议吧！ hpfeeds协议是什么？feeds，供稿，原始数据。 hpfeeds是一个轻量级的验证发布-订阅协议(authenticated publish-subscribe protocol)。 轻量级好理解，就是代码量相对较少，功能相对不复杂。那什么是发布-订阅协议呢？订阅发布协议定义了一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。它是为了解决这样一种情况的发生，一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象需要改变。我的理解，这就类似于发传单，目标发送通知，没有指定特定的对象，通知会自动传播，观察者自己决定是否需要看传单，发送者对于传单是否被看一无所知。 详细的发布订阅者介绍可以戳这里： https://msdn.microsoft.com/en-us/library/ff649664.aspx 线路协议组成如下： 首先是消息头：有两个参数，消息总长和消息类型 消息类型有以下几种： error (0): errormessage info (1): server name, nonce auth (2): client id, sha1(nonce+authkey) publish (3): client id, channelname, payload subscribe (4): client id, channelname 数字代表消息类型，而冒号后面的内容则代表后续的消息字段 比如说当消息类型为3，publish时，后面的字段就会有四个： client id的长度 client id channelname的长度 channelname payload 一个完整的消息如下： length | opcode | next | identifier | next | channelname|payload ---------------------------------------------------------------- 85 3 9 b4aa2@hp1 9 mwcapture 137941a3d8589f6728924c08561070bceb5d72b8,http://1.2.3.4/calc.exe 消息有了，整个消息的认证过程就是以下的几个步骤： 服务器为每一个连接生成一个标志 客户端发送id 和 标志+authkey组成的sha1 服务器检查id和sha1 服务器检查数据类型，是要发布还是要订阅 最终实现服务器、发布者、订阅者之间的解耦，彼此之间完全独立，互不干扰。 为什么要用hpfeeds协议首先，正如以上所说的，整个协议实现了三方的功能独立。使用这种方式降低了应用与业务逻辑之间的耦合，统一一个对外的发布接口，只需要关心监听的类型，不关心监听的具体处理人。只管发，不管到不到。很方便的建立一种一对多的依赖关系。 在当一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象需要改变时，就可以使用订阅发布模式。 hpfeeds协议希望能够实现一个单一的连线形式，使得每一个人都可以在任何时间以任何语言去订阅发布数据，不同的数据以通道来划分，由通道的使用者来决定数据结构形式。而通道的验证通过authkey来完成，它由两部分组成，ident和secret，相当于身份和密码。密码在hash后和每一个临时连接标志一起发送给服务器，这样保证不会被窃听，所以它可以运行在SSL、TLS下。 优点 1.降低耦合。发布者对于接收者的数量，身份，接收的数据类型一无所知。 2.安全性高。只有消息订阅者之间的单线信息交互，不存在其他程序的信息交换。 3.测试方便。 缺点 性能降低，订阅要进行管理 如何操作正常安装使用hpfeeds的步骤如下： git clone https://github.com/rep/hpfeeds/ cd hpfeeds python setup.py build python setup.py install 安装成功后，会出现下面几个文件夹。 appsuport：hpfeeds支持的一些蜜罐的应用程序 broker：服务器功能程序集，包括增加用户，服务器运行，查看所有用户信息等 build：一些编译环境 cli：用户程序 example：例程 lib：支持库 使用时先打开broker，运行其中的add_user.py添加用户信息： 根据提示信息，我们添加用户test，密码123456，拥有发布频道1，2，无订阅频道 再添加用户custom，密码123456，拥有订阅频道1，2，无发布频道 现在使用dump_users.py查看刚才创建的用户 如图所示，这里应经可以查看到刚才我们新建的用户了。 接下来，我们打开服务器feedbroker.py 再开启一个新的进程运行cli文件夹里的用户程序hpfeeds-client 先开启订阅者custom，使用1频道 此时，服务器端显示用户登录成功 我们再打开一个新的进程，以发布者test，使用1频道发布“helloworld” 我们可以看到发布者一旦发布完消息后，立即退出进程，并不确认消息是否收到 这时，服务器显示test登录成功 于此同时，订阅者custom成功接收到消息 到此，一次完整的发送、接收消息的流程就走完了。 通过这一过程，我们发现，频道与用户分离，发送和订阅者身份平等，只需订阅者实时监听，发送者可以即时发送即时撤出。 这里是对于hpfeeds协议的简单介绍，下一部分我会从代码的角度进一步分析该协议，并适当对于协议功能进行添加。","categories":[{"name":"article","slug":"article","permalink":"http://ipot.sec-wiki.com/categories/article/"}],"tags":[{"name":"蜜罐","slug":"蜜罐","permalink":"http://ipot.sec-wiki.com/tags/蜜罐/"},{"name":"MHN","slug":"MHN","permalink":"http://ipot.sec-wiki.com/tags/MHN/"},{"name":"hpfeeds","slug":"hpfeeds","permalink":"http://ipot.sec-wiki.com/tags/hpfeeds/"}]},{"title":"Elastichoney","slug":"honeypot-elastichoney","date":"2015-07-06T04:02:37.000Z","updated":"2017-05-22T08:49:48.411Z","comments":true,"path":"projects/2015-07-06-honeypot-elastichoney.html","link":"","permalink":"http://ipot.sec-wiki.com/projects/2015-07-06-honeypot-elastichoney.html","excerpt":"一款模拟elasticsearch的蜜罐 https://github.com/jordan-wright/elastichoney","text":"一款模拟elasticsearch的蜜罐 https://github.com/jordan-wright/elastichoney 介绍： Elastichoney是一个模拟Elasticsearch web界面的蜜罐。它可以捕捉通过web界面提交的payload，主要目的是捕捉相关的远程代码执行漏洞。","categories":[{"name":"projects","slug":"projects","permalink":"http://ipot.sec-wiki.com/categories/projects/"}],"tags":[{"name":"蜜罐","slug":"蜜罐","permalink":"http://ipot.sec-wiki.com/tags/蜜罐/"},{"name":"数据库","slug":"数据库","permalink":"http://ipot.sec-wiki.com/tags/数据库/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://ipot.sec-wiki.com/tags/elasticsearch/"}]},{"title":"Delilah","slug":"honeypot-delilah","date":"2015-06-10T05:57:48.000Z","updated":"2017-05-18T09:14:50.370Z","comments":true,"path":"projects/2015-06-10-honeypot-delilah.html","link":"","permalink":"http://ipot.sec-wiki.com/projects/2015-06-10-honeypot-delilah.html","excerpt":"一个识别攻击命令、侦查行为以及下载命令的elasticsearch蜜罐 https://github.com/Novetta/delilah","text":"一个识别攻击命令、侦查行为以及下载命令的elasticsearch蜜罐 https://github.com/Novetta/delilah 介绍： 安全公司Novetta的elasticsearch蜜罐，由elastichoney启发而来，它会执行攻击者的下载指令以获取攻击样本并会发送攻击向量到指定的邮箱。整个程序自带web管理端，使用Python语言编写。","categories":[{"name":"projects","slug":"projects","permalink":"http://ipot.sec-wiki.com/categories/projects/"}],"tags":[{"name":"蜜罐","slug":"蜜罐","permalink":"http://ipot.sec-wiki.com/tags/蜜罐/"},{"name":"数据库","slug":"数据库","permalink":"http://ipot.sec-wiki.com/tags/数据库/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://ipot.sec-wiki.com/tags/elasticsearch/"}]},{"title":"Mhn现代蜜网","slug":"mhn","date":"2015-05-07T07:06:04.000Z","updated":"2017-05-22T08:45:21.480Z","comments":true,"path":"article/2015-05-07-mhn.html","link":"","permalink":"http://ipot.sec-wiki.com/article/2015-05-07-mhn.html","excerpt":"本文作者：我是壮丁，转载自原wooyun知识库 http://drops.wooyun.org/papers/5968","text":"本文作者：我是壮丁，转载自原wooyun知识库 http://drops.wooyun.org/papers/5968 前言From: https://itandsecuritystuffs.wordpress.com/2015/02/03/honeypot-networks/ PS：测试过程中有的忘记截图了，就直接用的原文章的图片。翻译过程中做了少量的修改，英语好的可以直接看原文。 这篇文章中，主要讨论蜜罐和蜜罐网络，以及如何使用它们保护真实的系统，我们称之为这个系统为MHN(Modern Honey Network，现代蜜网)，它可以快速部署、使用，也能够快速的从节点收集数据。 什么是蜜罐蜜罐是存在漏洞的，暴露在外网或者内网的一个虚假的机器,具有以下这些特征： 1.其中重要的一点机器是虚假的，攻击者需要花费时间攻破。在这段时间内，系统管理员能够锁定攻击者同时保护真正的机器。 2.能够学习攻击者针对该服务的攻击技巧和利用代码。 3.一些蜜罐能够捕获恶意软件，利用代码等等，能够捕获攻击者的0day,同时可以帮助逆向工程师通过分析捕获的恶意软件来提高自身系统的安全性 4.在内网中部署的蜜罐可以帮助你发现内网中其他机器可能存在的漏洞。蜜罐是把双刃剑，如果不能正确的使用，有可能遭受更多的攻击，模拟服务的软件存在问题，也会产生新的漏洞。 蜜罐分为几下几类： １．低交互式：低交互式模拟常规的服务，服务存在漏洞，但是模拟的这些漏洞无法被利用，开发和维护这种类型的蜜罐比较容易。 ２．高交互式：高交互式使用的是真实的服务，有助于发现服务存在的新漏洞，同时能够记录所有的攻击，但是，部署困难、维护成本高，一旦服务上存在的漏洞被利用，容易引发新的安全问题。 ３．粘性蜜罐(Tarpits)：这种类型的蜜罐，使用新的IP来生成新的虚拟机，模拟存在服务的漏洞，来做诱饵。因此攻击者会花费长时间来攻击，就有足够的时间来处理攻击，同时锁定攻击者。 还有其他类型的蜜罐，比如专门捕获恶意软件的，数据库漏洞利用程序和垃圾邮件等等。当部署两个或者两个以上蜜罐时可以称之为蜜网。 网上关于蜜罐的一些定义： 1.什么是蜜罐： http://www.sans.org/security-resources/idfaq/honeypot3.php 2.蜜网： http://www.honeynet.org/ 3.蜜罐项目： https://www.projecthoneypot.org/，攻击者的ＩＰ和攻击者的一些数据统计。 4.蜜罐的wiki： http://en.wikipedia.org/wiki/Honeypot_(computing) 现代密网（MHN）MHN是一个开源软件，它简化了蜜罐的部署，同时便于收集和统计蜜罐的数据。用ThreatStream（http://threatstream.github.io/mhn/）来部署，MHN使用开源蜜罐来收集数据，整理后保存在Mongodb中，收集到的信息也可以通过web接口来展示或者通过开发的API访问。 MHN能够提供多种开源的蜜罐，可以通过web接口来添加他们。一个蜜罐的部署过程很简单，只需要粘贴，复制一些命令就可以完成部署，部署完成后，可以通过开源的协议hpfeeds来收集的信息。 MHN支持以下蜜罐： 1.Sort:https://www.snort.org/ 2.Suricata:http://suricata-ids.org/ 3.Dionaea:http://dionaea.carnivore.it/,它是一个低交互式的蜜罐，能够模拟MSSQL, SIP, HTTP, FTP, TFTP等服务 drops中有一篇介绍：http://drops.wooyun.org/papers/4584 4.Conpot:http://conpot.org/ 5.Kippo:https://github.com/desaster/kippo，它是一个中等交互的蜜罐，能够下载任意文件。 drops中有一篇介绍：http://drops.wooyun.org/papers/4578 6.Amun:http://amunhoney.sourceforge.net/，它是一个低交互式蜜罐，但是已经从2012年之后不在维护了。 7.Glastopf：http://glastopf.org/ 8.Wordpot：https://github.com/gbrindisi/wordpot 9.ShockPot：https://github.com/threatstream/shockpot，模拟的CVE-2014-6271，即破壳漏洞 10.p0f：https://github.com/p0f/p0f MHN的硬件要求MHN服务器： 4 GB Ram Dual Core Processor 40 Gb Drive 蜜罐： 512 Mb – 1 Gb Dual Core CPU 20 Gb Drive 具体部署时取决以蜜罐所在的位置，在防火墙后面或者在直接暴露在互联网上，被攻击次数不同，消耗的资源肯定也不同。如果只是测试着玩256M的内存就足够了。 MHN的安装因为ThreatStream有部署脚本，所以安装MHN很简单，我们在只安装了OpenSSH的Ubuntu 14.04 LTS (64 bits)上进行测试，安装步骤如下： #!bash sudo apt-get update &amp;&amp; sudo apt-get upgrade sudo apt-get install git cd /opt sudo git clone https://github.com/threatstream/mhn cd /opt/mhn/scripts 新版本中已经做了修改，安装前可以做一下检查 #!bash sudo vim install_mnemosyne.sh 找到修改CHANNELS，添加shockpot.events 修改成下面的样子 #!bash CHANNELS=’amun.events,conpot.events,thug.events,beeswarm.hive,dionaea.capture,dionaea.connections,thug.files,beeswarn.feeder,cuckoo.analysis,kippo.sessions,glastopf.events,glastopf.files,mwbinary.dionaea.sensorunique,snort.alerts,wordpot.events,p0f.events,suricata.events,shockpot.events’ sudo ./install_hpfeeds.sh sudo ./install_mnemosyne.sh sudo ./install_honeymap.sh 安装完成后执行sudo supervisorctl status看到四个服务起来了 机器位于公网，就可以跳过这一步，如果只是放在内网里面，则需要配置mnemosyne的配置文件 #!bash sudo vim /opt/mnemosyne/mnemosyne.cfg ignore_rfc1918 = False 允许节点使用私有地址和服务器进行通信 重启服务 #!bash sudo supervisorctl restart mnemosyne 运行最后一个脚本，对MHN进行配置 #!bash sudo ./install_mhnserver.sh =========================================================== MHN Configuration =========================================================== Do you wish to run in Debug mode?: y/n n Superuser email: name@example.com Superuser password: Superuser password: (again): Server base url [“http://1.2.3.4″]: http://192.168.5.3 Honeymap url [http://1.2.3.4:3000]: http://192.168.5.3:3000 Mail server address [“localhost”]: Mail server port [25]: Use TLS for email?: y/n y Use SSL for email?: y/n y Mail server username [“”]: Mail server password [“”]: Mail default sender [“”]: Path for log file [“mhn.log”]: 这个过程需要比较长的时间，需要初始化数据库，同时还要插入Snort/Suricata规则，脚本运行结束后，直接访问配置中定义的base url，登录后就可以配置 MHN服务器安装一旦安装了基础的服务，就能够部署蜜罐节点了，通过web来展示相关数据等等，可以根据具体的境况做一些简单的调整。 例如要非匿名的将收集到得攻击数据回传到ThreatStream，要做以下操作 #!bash cd /opt/mhn/scripts sudo ./disable_collector.sh 执行enable_collector.sh可以开启 如果想修改smtp服务的配置，可以编辑config.py， 绝对路径 #!bash /opt/mhn/server/config.py cd /opt/mhn/server sudo vim config.py sudo supervisorctl restart mhn-uwsgi 尽量不要使用超级管理员来配置，可以从web页面中添加其他的用户，但是所有用户都是超级用户，没有任何区别，当你删除用户的时候，实际上并没有吧该用户删除，只是在数据库中标记为”not active”,同时该用户不能再次被使用，除非更改数据库。 也可以从终端去直接更改用户的密码 #!bash sudo su cd /opt/mhn/ source env/bin/activate cd server python manual_password_reset.py deactivate exit 排错如果发现服务不正常，你可以使用一些命令和排查一些日志来来判断问题出在哪里，第一个命令就是supervisorctl，可以看到那些进程出问题了，那些在正常的运行 #!bash supervisorctlv status #列出所有进程的状态 supervisorctl restart [process|all] #重启单个或者全部进程 supervisorctl start [process|all] #开始单个进程或者全部进程 supervisorctl stop [process|all] #停止单个进程或者全部进程 如果你发现一个进程的状态为ERROR或者FATAL，就需在 /etc/supervisor/conf.d/找到对应进程的配置文件，查看日志进行分析 https://github.com/threatstream/mhn/wiki/MHN-Troubleshooting-Guide，寻求帮助 遇到的问题： 1.honeymap在安装的时候报错 #!bash hg clone http://code.google.com/p/go.net/ mv go.net/ /opt/honeymap/server/src/code.google.com/p/ go build supervisorctl restart honeymap MNH的web接口MHN的web接口是很简洁明了的，第一次访问web截面时，需要输入账户名和密码，登录成功后会看见一个总结性的页面 1.在最近24小时内有多少攻击着攻击 2.攻击次数排在前五的IP 3.被攻击端口排在前五的端口 4.top 5的攻击签名 还有一些菜单选项可以进行配置或者获取更多的攻击细节 Map:查看攻击者的IP在全球的分布 Deploy:添加，编辑和使用蜜罐的部署脚本 Attacks:所有攻击者的列表 Payloads:所有攻击的payload，其实只有三种蜜罐可以收集payload(snort,dionaea.glastofp) Rules:所有的snort和suricata规则 Seneors:有安装蜜罐节点操作的相关记录 Settings:MHN服务的设置 攻击来源全球的分布图,运行在3000端口，是不需要验证就能看到的，可以做ACL开控制访问。 蜜罐节点这一节中，主要讨论蜜罐，如何安装，多么容易操作，以及会出现的问题，是否需要在进行特殊的配置等等。也会进行一些测试，看攻击者如何攻击，蜜罐对攻击行为的记录。最后会讨论MHN如何收集信息，以及web所展现的数据。 安装蜜罐节点安装蜜罐节点很容易，所有的节点都基于同样的平台，MHN上对每个蜜罐都有对应的安装脚本，所以安装起来是非常容易的，只需要一个服务器去安装。 我们在Ubuntu 14.04 LTS 上进行测试。建议通过ssh去访问，如果不可以，请安装ssh，修改对应的22端口，同时加防火墙保护 安装ssh #!bash sudo apt-get update &amp;&amp; sudo apt-get upgrade &amp;&amp; sudo apt-get install openssh-server 修改端口为2222 #!bash vim /etc/ssh/sshd_config Port 2222 重启服务 #!bash sudo service ssh restart 定义的安装脚本在MHN服务器的web界面中，在”Deploy”这个选项下有所有蜜罐的安装脚本。 http://192.168.5.11/ui/manage-deploy/?script_id=11 安装完成后可以通过以下命令来检查 #!bash sudo netstat –tunlp ＃产看当前的网络连接情况 supervisorctl status #查看运行状态 Wordpot首先，安装一个wordpress蜜罐在Ubuntu 14.04 LTS上，安装完成后 sudo netstat –tunlp查看80端口是否打开， sudo supervisorctl status可以查看服务的运行状态。 访问后该ip,看到下图 如果想更改wp的插件和相关设置， #!bash vim /opt/wordpot/wordpot.conf 使用nmap扫描该80端口 #!bash nmap -A -Pn -p80 192.168.10.21 通过nmap识别80看到的是wordpress 2.8，运行的http版本是0.96,识别出来的python 2.7.6的版本。这种端口扫描不会被记录，回传到MHN服务。 使用wpscan进行扫描 #!bash wpscan –url http://ip/ p0f被动指纹识别系统p0f是一个被动的系统指纹识别工具，借助它可以快速识别操作系统的类型和其他的信息，它在MHN中部署也是很容易的，p0f有可以根据已有的指纹，能够快速的匹配，虽然不是一个精确计算，但是识别度很高。 通过netstat命令的输出可以看到没有p0f没有去新建新的进程来实现网络监听。 如果所要保护的ssh端口处于防火墙后或者前端有一个IPS/IDS，获取这些数据的时候就比较麻烦。 如果我们在安装了wordpot的机器上安装p0f，一个访问wordpot的80端口的请求不会触发wordpot的报警，但是p0f会触发，MHN只是能够显示攻击者攻击的端口，但是不能显示关于操作系统类型，uptime和其他的信息。p0f的日志是纯文本的，分析和收集数据不是太容易，还好p0f存在API，还有一些其他的工具，可以帮助我们快速分析。 如果需要正在进行攻击的系统系统的信息，可以从/var/log/p0f.out中提取，可以使用python、bash、sed、grep等来帮助你快速的获取想要的信息。 想要获取相关ip的系统信息，可以使用以下这个命令 #!bash grep -n “\\[ 192.168.10.151.*\\(syn\\)\\|os\\s*=” /var/log/p0f.out 如果想要获得更多关于p0f的信息，访问 http://www.sans.org/security-resources/idfaq/p0f.php，查看相关接口信息https://github.com/p0f/p0f/blob/master/docs/README，还有很重要的一点，p0f把攻击的信息保存在MHN服务的mongodb中，其他的一些信息，如操作系统类型等信息没有展现出来，有可能下一个版本会对这些信息进行展示。 kippo蜜罐kippo是一个中等交互式的ssh蜜罐，安装它很容易，但是要注意以下 1.ssh服务默认监听的是22端口，/etc/ssh/sshd_config为默认配置文件，要想正常运行，需要修改监听端口到2222。 2.安装完成后需要重启服务。 3.supervisor可以使kippo程序运行，但是不能够停止它，这需要修改部署脚本 进入web的deploy界面，选择kippo,在部署脚本后添加下面这些东西 #!bash command=/opt/kippo/start.sh #modify this command for the line below command=su kippo -c “authbind –deep twistd -n -y /opt/kippo/kippo.tac -l /opt/kippo/log/kippo.log –pidfile /opt/kippo/kippo.pid” stopsignal=QUIT #Modify this line for the line below stopasgroup=true 编辑完成后点击update保存，安装完成后就可以看到kippo监听在22端口,ssh服务在2222端口，下次ssh登录的服务器的时候需要指定ssh -p 2222 ip，否则登录的为kippo。 以下是一些关于kippo的介绍，包括如何配置以及工作原理： 1.默认的ssh登录账户名密码为root/12345,也可以进行配置，配置的路径在 /opt/kippo/data/userdb.txt，同时当攻击者登陆后，使用useradd和passwd添加账户和密码的时候也会保存在这个文件里面． 2.当攻击者下载文件时，下载的文件会被保存在/opt/kippo/dl 3.可以设置蜜罐中命令执行后的返回值，也可以添加命令．例如来修改ifconfig命令的输出，可以编辑/opt/kippo/txtcmds/sbin/ifconfig这个文本文件。 4.有一个特点就是，当攻击者输入exit想退出的时候，其实没有退出，只是显示退出，给攻击者一个假象，以为回到的他的本机，他接下来的操作还是会被记录到日志中。 5.你可以更改/opt/kippo/honeyfs，里面保存模拟的系统的文件等内容，使蜜罐更像真实环境。 6.log存储在/opt/kippo/log/kippo.log，你也可以修改配置，把log存储到数据库中，数据库的表结构在 /opt/kippo/doc/sql目录中。 7.每一次登录成功后的操作都会把日志单独再存储一份，存储的路径在/opt/kippo/log/tty,可以通过在/opt/kippo/utils中的playlog.py脚本，来重现这个操作过程。安装和配置kippo后，如果有人尝试登录，会被记录登录所使用的用户名和密码。 我们用nmap来扫描，看到以下信息 根据nmap的输出，我们看到22端口已经被识别为ssh服务，其中输出的ssh版本能够在kippo.cfg中被修改，这种简单的扫描是不会在MHN服务上产生记录的 如果我们使用hydra(https://www.thc.org/thc-hydra/),去进行暴力破击(hydra -l root -P darkc0de.lst ssh://192.168.10.21),hydra在连接的时候 会出现一些问题，但是我们使用 medusa(http://foofus.net/goons/jmk/medusa/medusa.html)时，暴力破解的命令如下 #!bash medusa -u root -P darkc0de.lst -M ssh -h 192.168.10.21 每进行一次尝试登录，都会产生一条扫描记录，如果想更了解kippo，可以参考http://edgis-security.org/honeypot/kippo/ Suricata网络入侵检测和阻止引擎Suricata的部署脚本没有问题，直接执行就好了，部署完成后需要重启服务。Suricata是一个IDS,监听的接口为eth0,规则是通过crontab中的/etc/cron.daily/update_suricata_rules.sh脚本，每天都从MHN服务更新的(可以开启或者关闭规则) 正如supervisor显示的，只有一个进程，没有生成其他的服务，因为他只是一个IDS,如果我们使用nmap进行扫描，只看到一个ssh服务，这侧扫描会被记录，同时在MHN中显示 Suricata只会把攻击报告给MHN服务，但是攻击细节存储在Suricata的日志中，不会被显示 1./var/log/suricata.log:日志记录了Suricata进程相关的信息，如启动报错，错误的规则等等，这份日志由supervisor产生2./var/log/suricata/：设计到suricata操作的输入日志，报警日志，http请求日志，dns请求日志等等3./var/log/suricata/http.log：http请求，不是报警4./var/log/suricata/fast.log：一行存储一个报警5./var/log/suricata/eve.json：格式为json，包含报警和相关的事件6./var/log/suricata/unified2.alert：报警文件为Barnyard2格式（http://www.forensicswiki.org/wiki/Barnyard2） Suricata的配置文件 1./opt/suricata/etc/suricata/classification.config :报警的优先级2./opt/suricata/etc/suricata/reference.config ：使用的漏洞数据库3./opt/suricata/etc/suricata/suricata.yaml ：suricata的配置文件4./opt/suricata/etc/suricata/reference.config ：通过配置来减少报警的数量，例如不想记录所有ICMP请求的来源为一样的ＩＰIDS/IPS配置是很复杂的，这里只是简单的说明，需要详细了解suricata的，访问这里http://suricata-ids.org/docs/ snortsnort是像Suricata一样的IDS/IPS，和Suricata使用类似的规则，同时工作方式也很像，同样部署脚本没有问题，通过crontab.daily来更新规则库，不会其他用来监听连接的服务 它的配置文件和Suricata使用的suricata.yaml很像，它的配置文件为snort.conf，日志存储在/var/log/snort/alert目录下. 想更加了解snort，访问https://www.snort.org/ AmunAmun蜜罐已经好久没有更新了，这里不做过多的讨论。 ShockpotShockpot是一个web蜜罐，用来模拟破壳漏洞,CVE-2014-6271 http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-6271,破壳漏洞是一个影响很广泛的漏洞，影响Mac OsX,Linux和Unix，这个漏洞产生在GNU Bash(shell)上，允许远程命令执行，虽然已经出现了补丁，但不是所有的机器都有更新。使用这个蜜罐，可以用来捕获这个漏洞的利用代码， 关于这个漏洞的详情https://shellshocker.net/ 部署脚本有一些问题，进入Deploy页面，选择Shockpot对期做一点修改,在＂#Config for supervisor. ＂和＂EOF＂中加入一下代码 [fetch_public_ip] enabled = false urls = [“http://api.ipify.org&quot;,” http://bot.whatismyipaddress.com/”] 如果服务器有公网IP，就加入上面这一段． 安装完成后重启服务 看到以下运行的进程，有一个新的服务在80上监听 如果通过浏览器去访问http://ip ，会看到”It Works!”这个默认的Apache页面 telnet ip 80 GET / HTTP/1.0 显示这是一个Debian服务器，使用了PHP和OpenSSL nmap -A -p80 192.168.10.21 上面的这些操作MHN是不会记录的，下面我们来攻击蜜罐 #!bash curl -H “User-Agent: () { :; }; /bin/ping -c 1 TARGET_HOST_IP” http://SHOCKPOT_IP 我看看到日志里输出/var/log/shockpot/shockpot.log report 更多关于破壳的利用https://blog.cloudflare.com/inside-shellshock/ ConpotConpot是一个工业控制系统和Scada蜜罐，针对这些类型的攻击是在近几年快速增长，是因为安全在工业系统中要求较低，才造成了现在这种场面，安全专家们也在想办法保护这些脆弱的系统。 安装简单，安装完成后需要重启服务，使用supervisorctl status 可以看到一个进程，但是使用netsta 可以看到好几个监听的端口。 Conpot使用了一些模块，能够提供以下服务 MODBUS TCP —&gt; tcp/502 HTTP —&gt; tcp/80 SNMP —&gt; udp/161 S7COMM —&gt; tcp/102 使用nmap扫描 nmap -A -p1-1000 192.168.10.21 #!bash nmap -sU -p161–script snmp-sysdescr 192.168.10.21 GlastopfGlastopf是最好的web蜜罐，它模拟了很多漏洞，特别是远程文件包含漏洞，可以捕获到攻击只插入的文件．部署依旧很简单，安装完成后重启服务，你会看到一个进程 模拟的http,mongodb只在本地监听． #!bash nmap -A -p80 192.168.10.21 你能看到模拟的是apache，我们使用web漏洞扫瞄器像niko(https://cirt.net/Nikto2) nikto -h 192.168.10.21 nikto报告了5536个项目，显然蜜罐对攻击者很有吸引力，我们到MHN的web界面上看到所有的攻击报告，但是如果我们点击Payload，选择glastopf.events,我们可以看到很多记录，在“Regex term”中输入”rfi”会看到下面这些 对于这些被下载的文件，我们能够看到它们的md5值，这些文件都保存在/opt/glastopf/dataGlastopf是很好配置的，/opt/glastopf/glastopf.cfg配置文件，日志/opt/glastopf/log/glastopf.log. 官网 https://www.honeynet.org/sites/default/files/files/KYT-Glastopf-Final_v1.pdf dionaeadionaea将有漏洞的服务暴露出来，允许攻击者发送保存任何文件，安装简单 服务列表 #!bash tcp/5060 —&gt; SIP Protocol tcp/5061 —&gt; SIP Protocol over TLS tcp/135 —&gt; Remote procedure Call RPC tcp/3306 —&gt; MySQL Database tcp/42 —&gt; WINS Protocol tcp/21 —&gt; FTP Protocol tcp/1433 —&gt; MSSQL tcp/445 —&gt; SMB over TCP udp/5060 —&gt; SIP Protocol udp/69 —&gt; TFTP nmap -sS -sV -p1-65535 192.168.10.21 在扫描结果中，我们看到ftp和smb服务的指纹是＂Dionaea Honeypot＂，这种扫描产生的记录都被记录了，扫描UDP #!bash nmap -sU -sV -p69,5060 192.168.10.21 我们没有修改banner，会被nmap识别，如果需要修改，编辑 /usr/lib/dionaea/python/dionaea这个python文件，需要更加了解他，访问http://www.securityartwork.es/2014/06/05/avoiding-dionaea-service-identification/?lang=en，配置文件在 /etc/dionaea/dionaea.conf,日志保存在/var/dionaea/log/dionaea.log 使用nessus进行扫描，发现了53个问题，45个info，３个紧急 我们看到有MS04-007漏洞，这个漏洞能够执行任意代码，通过向主机发送ASN.1编码后的数据包，Metasploit中使用的模块是 “MS04-007 Microsoft ASN.1 Library Bitstring Heap Overflow”，使用Metasploit发起攻击，会返回“The SMB server did not reply to our request”，这种攻击会报告给mhn,攻击的细节保存在/var/dionaea/bistreams/ 总结我们已经大概了解了mhn的总体概况，怎么安装和怎么去部署蜜罐节点，还有这些蜜罐大概的一些情况。如果你清楚你想做的，部署蜜网是很有用的．可以获取攻击者更准确的信息，然后来做防御。 在部署蜜罐节点是，尽可能的根据具体情况来组合部署，这样可以是攻击者花费更多的时间，从中获取更多的信息，争取到更多的响应时间。 例如snort,Glastopf,Dionaea和kippo，在具体部署之前先要好好测试，避免在真实环境中出现意想不到的问题。 个人的看法： 曾经做过类似的一个东西，不过相比这个来说就有些粗糙了，MHN中支持的开源蜜罐种类很多，基本已经涵盖了现有所有的开源蜜罐，可以根据具体的业务场景来组合。也可以根据具体的场景来做二次开发，因为回传的数据有些简单了。如果是放置在内网中，报警功能就很有必要性，内网中得蜜罐只是为了能够延缓攻击的进度，以及及时发现入侵，从而切断入口。","categories":[{"name":"article","slug":"article","permalink":"http://ipot.sec-wiki.com/categories/article/"}],"tags":[{"name":"蜜罐","slug":"蜜罐","permalink":"http://ipot.sec-wiki.com/tags/蜜罐/"},{"name":"mhn","slug":"mhn","permalink":"http://ipot.sec-wiki.com/tags/mhn/"}]},{"title":"Espot","slug":"honeypot-espot","date":"2014-08-25T05:53:33.000Z","updated":"2017-05-22T08:50:02.264Z","comments":true,"path":"projects/2014-08-25-honeypot-espot.html","link":"","permalink":"http://ipot.sec-wiki.com/projects/2014-08-25-honeypot-espot.html","excerpt":"一个专门捕捉CVE-2014-3120漏洞利用的elasticsearch蜜罐 https://github.com/mycert/ESPot","text":"一个专门捕捉CVE-2014-3120漏洞利用的elasticsearch蜜罐 https://github.com/mycert/ESPot 介绍： Espot使用NodeJS语言，专门用来捕捉对CVE-2014-3120漏洞的攻击向量。","categories":[{"name":"projects","slug":"projects","permalink":"http://ipot.sec-wiki.com/categories/projects/"}],"tags":[{"name":"蜜罐","slug":"蜜罐","permalink":"http://ipot.sec-wiki.com/tags/蜜罐/"},{"name":"数据库","slug":"数据库","permalink":"http://ipot.sec-wiki.com/tags/数据库/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://ipot.sec-wiki.com/tags/elasticsearch/"}]},{"title":"Servletpot","slug":"honeypot-servletpot","date":"2013-05-12T09:11:39.000Z","updated":"2017-05-18T09:19:26.609Z","comments":true,"path":"projects/2013-05-12-honeypot-servletpot.html","link":"","permalink":"http://ipot.sec-wiki.com/projects/2013-05-12-honeypot-servletpot.html","excerpt":"一个灵感来源于Glastopf的web应用蜜罐 https://github.com/schmalle/Servletpot","text":"一个灵感来源于Glastopf的web应用蜜罐 https://github.com/schmalle/Servletpot 介绍： Servletpot蜜罐使用JAVA语言编写，主要用来模拟Servelet容器的相关的web应用。","categories":[{"name":"projects","slug":"projects","permalink":"http://ipot.sec-wiki.com/categories/projects/"}],"tags":[{"name":"蜜罐","slug":"蜜罐","permalink":"http://ipot.sec-wiki.com/tags/蜜罐/"},{"name":"web","slug":"web","permalink":"http://ipot.sec-wiki.com/tags/web/"},{"name":"servlet","slug":"servlet","permalink":"http://ipot.sec-wiki.com/tags/servlet/"}]},{"title":"Mysqlpot","slug":"honeypot-mysqlpot","date":"2012-10-15T04:49:22.000Z","updated":"2017-05-18T05:53:00.980Z","comments":true,"path":"projects/2012-10-15-honeypot-mysqlpot.html","link":"","permalink":"http://ipot.sec-wiki.com/projects/2012-10-15-honeypot-mysqlpot.html","excerpt":"一个还在早期开发状态的Mysql蜜罐 https://github.com/schmalle/MysqlPot","text":"一个还在早期开发状态的Mysql蜜罐 https://github.com/schmalle/MysqlPot 介绍： 一款Mysql蜜罐，处于也有可能永远都处于开发状态。","categories":[{"name":"projects","slug":"projects","permalink":"http://ipot.sec-wiki.com/categories/projects/"}],"tags":[{"name":"蜜罐","slug":"蜜罐","permalink":"http://ipot.sec-wiki.com/tags/蜜罐/"},{"name":"数据库","slug":"数据库","permalink":"http://ipot.sec-wiki.com/tags/数据库/"},{"name":"mysql","slug":"mysql","permalink":"http://ipot.sec-wiki.com/tags/mysql/"}]},{"title":"A Dynamic Honeypot Design for Intrusion Detection","slug":"A-Dynamic-Honeypot-Design-for-Intrusion-Detection","date":"2004-06-23T06:47:17.000Z","updated":"2017-05-18T07:53:30.531Z","comments":true,"path":"papers/2004-06-23-A-Dynamic-Honeypot-Design-for-Intrusion-Detection.html","link":"","permalink":"http://ipot.sec-wiki.com/papers/2004-06-23-A-Dynamic-Honeypot-Design-for-Intrusion-Detection.html","excerpt":"本文讨论了动态蜜罐的设计，实现了一个可以在动态和连续变化的网络环境下进行自适应部署的蜜罐。这种动态蜜罐实现方法集成了主动和被动探测功能以及一些虚拟蜜罐。这种方法解决了虚拟蜜罐部署和配置困难的问题。","text":"本文讨论了动态蜜罐的设计，实现了一个可以在动态和连续变化的网络环境下进行自适应部署的蜜罐。这种动态蜜罐实现方法集成了主动和被动探测功能以及一些虚拟蜜罐。这种方法解决了虚拟蜜罐部署和配置困难的问题。 论文原文 http://ieeexplore.ieee.org/abstract/document/1372012/ 引用： Kuwatly I, Sraj M, Al Masri Z, et al. A dynamic honeypot design for intrusion detection[C]//Pervasive Services, 2004. ICPS 2004. IEEE/ACS International Conference on. IEEE, 2004: 95-104. 0x01 前言前言部分列举出当前的网络安全解决方案，包括防火墙、VPN和IDS等，但是这些措施依然不够有效，美国联邦调查局2003年度的计算机犯罪与安全调查表明，2003年因此损失金额201,797,340美元。 而高级的网络解决方案往往需要企业进行大量的管理配置工作。 0x02 入侵检测系统这一部分介绍了入侵检测系统的类别。 0x03 相关工作这一部分介绍了蜜罐的定义、蜜罐的类型。 0x04 动态蜜罐动态蜜罐概念的产生来源于对蜜网组织想法的响应，如何在网络拓扑结构或者网络技术发生改变后，安全系统依然能够有效运行。 所以论文作者系统设计实现一种只需要插入组件、不需要持续更新就能正常运作的动态蜜罐。这就要求蜜罐能够识别空闲ip，并在这些ip上进行部署。 这个论文设计架构如上。 动态蜜罐服务器收集网络中可用主机的信息，黑客的流量通过Honeyd重定向与物理蜜罐进行交互，使用Sebek记录日志并发送到动态蜜罐服务器上。服务器持续分析收集到的数据并发送警报。而整个蜜罐系统的运作模式来源于动态蜜罐服务器所获取到的网络结构，它会根据当前结构来估计需要进行配置的虚假系统的服务和特性，然后生成配置参数给Honeyd，配置出不同的Honeyd蜜罐。 其中动态蜜罐服务器拥有主动探测（Nmap）、被动探测（P0f）、蜜罐（Honeyd、物理蜜罐）、数据库、动态配置生成器几部分组成。 论文还着重讨论了整个设计的性能参数，测试环境是一个拥有70-75台电脑，3个打印机的环境，系统涵盖Windos和Linux。测试得知，动态蜜罐的吞吐量可以达到100万比特。通过测试动态蜜罐中Nmap的收敛时间来衡量整个系统的动态部署时间。 0x05 总结这篇论文主要的亮点是它提出了根据部署环境动态生成蜜罐配置，来适应变化的网络拓扑，另外一点是它混合使用两种高低交互的蜜罐，使用低交互蜜罐先获取流量，再将无法处理的流量转发到高交互蜜罐中。","categories":[{"name":"papers","slug":"papers","permalink":"http://ipot.sec-wiki.com/categories/papers/"}],"tags":[{"name":"蜜罐","slug":"蜜罐","permalink":"http://ipot.sec-wiki.com/tags/蜜罐/"},{"name":"入侵检测","slug":"入侵检测","permalink":"http://ipot.sec-wiki.com/tags/入侵检测/"}]}]}